# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/unicorn/all/unicorn.rbi
#
# unicorn-5.5.5

module Unicorn::Const
end
module Unicorn
  def self.builder(ru, op); end
  def self.listener_names; end
  def self.log_error(logger, prefix, exc); end
  def self.pipe; end
end
class Unicorn::TCPClient < Kgio::Socket
end
class Unicorn::TCPSrv < Kgio::TCPServer
  def kgio_tryaccept; end
end
module Unicorn::SocketHelper
  def bind_listen(address = nil, opt = nil); end
  def log_buffer_sizes(sock, pfx = nil); end
  def new_tcp_server(addr, port, opt); end
  def self.sock_name(sock); end
  def self.tcp_name(sock); end
  def server_cast(sock); end
  def set_server_sockopt(sock, opt); end
  def set_tcp_sockopt(sock, opt); end
  def sock_name(sock); end
  def tcp_name(sock); end
end
class Unicorn::StreamInput
  def each; end
  def eof!; end
  def eof?; end
  def filter_body(dst, src); end
  def gets; end
  def initialize(socket, request); end
  def read(length = nil, rv = nil); end
  def read_all(dst); end
end
class Unicorn::TeeInput < Unicorn::StreamInput
  def consume!; end
  def gets; end
  def initialize(socket, request); end
  def new_tmpio; end
  def read(*args); end
  def rewind; end
  def self.client_body_buffer_size; end
  def self.client_body_buffer_size=(bytes); end
  def size; end
  def tee(buffer); end
end
class Unicorn::HttpParser
  def add_parse(arg0); end
  def body_eof?; end
  def buf; end
  def call; end
  def check_client_connection(socket); end
  def clear; end
  def closed_state_str?(state); end
  def content_length; end
  def env; end
  def filter_body(arg0, arg1); end
  def headers(arg0, arg1); end
  def headers?; end
  def hijacked!; end
  def hijacked?; end
  def initialize; end
  def keepalive?; end
  def next?; end
  def parse; end
  def read(socket); end
  def response_start_sent; end
  def response_start_sent=(arg0); end
  def self.check_client_connection; end
  def self.check_client_connection=(bool); end
  def self.input_class; end
  def self.input_class=(klass); end
  def self.is_chunked?(v); end
  def self.max_header_len=(arg0); end
  def trailers(arg0, arg1); end
  def write_http_header(socket); end
end
module Unicorn::HttpResponse
  def err_response(code, response_start_sent); end
  def http_response_write(socket, status, headers, body, req = nil); end
  def httpdate; end
end
class Unicorn::Configurator
  def [](key); end
  def after_fork(*args, &block); end
  def after_reload; end
  def after_reload=(arg0); end
  def after_worker_exit(*args, &block); end
  def after_worker_ready(*args, &block); end
  def before_exec(*args, &block); end
  def before_fork(*args, &block); end
  def canonicalize_tcp(addr, port); end
  def check_bool(var, bool); end
  def check_client_connection(bool); end
  def client_body_buffer_size(bytes); end
  def commit!(server, options = nil); end
  def config_file; end
  def config_file=(arg0); end
  def default_middleware(bool); end
  def expand_addr(address); end
  def initialize(defaults = nil); end
  def listen(address, options = nil); end
  def listeners(addresses); end
  def logger(obj); end
  def parse_rackup_file; end
  def pid(path); end
  def preload_app(bool); end
  def reload(merge_defaults = nil); end
  def rewindable_input(bool); end
  def set; end
  def set=(arg0); end
  def set_bool(var, bool); end
  def set_hook(var, my_proc, req_arity = nil); end
  def set_int(var, n, min); end
  def set_path(var, path); end
  def stderr_path(path); end
  def stdout_path(path); end
  def timeout(seconds); end
  def user(user, group = nil); end
  def worker_exec(bool); end
  def worker_processes(nr); end
  def working_directory(path); end
  include Unicorn
end
class Unicorn::TmpIO < File
  def close!; end
  def self.new; end
end
module Unicorn::Util
  def self.chown_logs(uid, gid); end
  def self.is_log?(fp); end
  def self.reopen_logs; end
end
class Unicorn::Worker
  def ==(other_nr); end
  def atfork_child; end
  def atfork_parent; end
  def close; end
  def fake_sig(sig); end
  def initialize(nr, pipe = nil); end
  def kgio_tryaccept; end
  def master; end
  def nr; end
  def nr=(arg0); end
  def quit; end
  def soft_kill(sig); end
  def switched; end
  def switched=(arg0); end
  def tick; end
  def tick=(value); end
  def to_io; end
  def user(user, group = nil, chroot = nil); end
end
class Unicorn::HttpServer
  def after_fork; end
  def after_fork=(arg0); end
  def after_fork_internal; end
  def after_worker_exit=(arg0); end
  def after_worker_ready=(arg0); end
  def app; end
  def app=(arg0); end
  def awaken_master; end
  def before_exec; end
  def before_exec=(arg0); end
  def before_fork; end
  def before_fork=(arg0); end
  def bind_new_listeners!; end
  def build_app!; end
  def check_client_connection; end
  def check_client_connection=(bool); end
  def client_body_buffer_size; end
  def client_body_buffer_size=(bytes); end
  def clobber_pid(path); end
  def close_sockets_on_exec(sockets); end
  def config; end
  def config=(arg0); end
  def default_middleware; end
  def default_middleware=(arg0); end
  def e100_response_write(client, env); end
  def handle_error(client, e); end
  def inherit_listeners!; end
  def init_worker_process(worker); end
  def initialize(app, options = nil); end
  def join; end
  def kill_each_worker(signal); end
  def kill_worker(signal, wpid); end
  def listen(address, opt = nil); end
  def listener_names(listeners = nil); end
  def listener_opts; end
  def listener_opts=(arg0); end
  def listener_sockets; end
  def listeners=(listeners); end
  def load_config!; end
  def logger; end
  def logger=(obj); end
  def maintain_worker_count; end
  def master_sleep(sec); end
  def murder_lazy_workers; end
  def nuke_listeners!(readers); end
  def orig_app; end
  def orig_app=(arg0); end
  def pid; end
  def pid=(path); end
  def preload_app; end
  def preload_app=(arg0); end
  def proc_name(tag); end
  def process_client(client); end
  def ready_pipe; end
  def ready_pipe=(arg0); end
  def reap_all_workers; end
  def redirect_io(io, path); end
  def reexec; end
  def reopen_worker_logs(worker_nr); end
  def rewindable_input; end
  def rewindable_input=(bool); end
  def soft_kill_each_worker(signal); end
  def spawn_missing_workers; end
  def start; end
  def stderr_path=(path); end
  def stdout_path=(path); end
  def stop(graceful = nil); end
  def time_now; end
  def timeout; end
  def timeout=(arg0); end
  def unlink_pid_safe(path); end
  def user; end
  def user=(arg0); end
  def valid_pid?(path); end
  def worker_exec=(arg0); end
  def worker_loop(worker); end
  def worker_processes; end
  def worker_processes=(arg0); end
  def worker_spawn(worker); end
  include Unicorn::HttpResponse
  include Unicorn::SocketHelper
end
class Unicorn::ClientShutdown < EOFError
end
